\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[{italian, english}]{babel}
\usepackage{verbatimbox}
\usepackage{fancyvrb}


\begin{document}

	\author{Fabio Chiarani}
	\title{SQL - Dispensa Basi Di Dati 2019}

	\maketitle
	\tableofcontents
	\pagebreak
	\section{Introduzione}
		SQL è un linguaggio iterattivo nato negli anni '70-'90. Noi vedremmo SQL2 e non SQL3.
		SQL è quindi un linguaggio di interrogazione dichiarativo (\emph{indico le propietà che deve avere il risultato. Non dico come, 			ma indico le proprietà}) e fa riferimento al calcolo relazionale (logica del primo ordine).

		La fomra base di una \emph{query} è :

		\begin{verbbox}
				SELECT <ListaAttributi>
				FROM  <ListaTabelle>
				[WHERE <condizione>] 
			\end{verbbox}

		\begin{center}
			\theverbbox
		\end{center}

		Indicando con [\dots] opzionalità (può mancare).
		\\
		\\
		Lo \emph{schema} risultante di una \emph{query} è costituito dagli attributi indicati in \verb <ListaAttributi>  della clausola 			\verb SELECT. Il contenuto sono tuple proiettato su \verb <ListaAttributi>  dove le tuple \verb t' di \verb <ListaTabelle>  				soddisfano la condizione \verb WHERE  nella nostra \emph{query}. 
		
		\subsection{Schema di appoggio}
		Per gli esempi in questa prima parte utilizzerò il sequente schema:

		\subsection{Visite}
		La visita è una relazione derivata. Si specifica l'espressione che  genera il suo contenuto. Esso dipende quindi dalle 
		relazioni che compaiono nell'espressione.

		Una visita si dice \emph{virtuale} se viene calcolata ogni volta che serve. 
		Una visita si dice \emph{materializzata} se viene calcolata e memorizzata esplicitamente nella base di dati.

	\begin{Verbatim}[commandchars=+\[\]]
		TRENO(+underline[NUM], CAT, PART, ARRIVO, DEST)
		FERMATA(+underline[TRENO, STAZIONE], ORARIO)
	\end{Verbatim}

	\section{Clausola SELECT}
	\verb SELECT <ListaAttributi>  , dove \emph{<ListaAttributi>} è una lista di espressioni con la seguente sintassi:
	\begin{Verbatim}
	< [DISTINCT] <espr> [[AS] <alias>] {, <espr> [[AS] <alias> ]} | * >
	\end{Verbatim}


	Indicando con:
	\begin{itemize}
		\item \verb [WORD]  Una parola chiave
		\item \verb |  oppure (\emph{or})
		\item \verb <alias>  un nuovo nome che assegno all'attributo (\emph{aliasing})
		\item \verb *  '\emph{star}', ossia prendo tutti gli attributi
		\item \verb  <espr>  è una espressione che coinvolge gli attributi della tabella
		\item \verb DISTINCT  serve per eliminare i duplicati nella relazione risultato. Non produce quindi risultati (se ho una superchiave non serve)
	\end{itemize}

	\section{Clausola FROM}
	\verb FROM <ListaTabelle>  , dove \emph{<ListaTabelle>} è una lista di espressioni con la seguente sintassi:
	\begin{Verbatim}
	<tabella> [[AS] <alias>] {, <tabella> [[AS] <alias> ]}
	\end{Verbatim}


	\begin{itemize}
		\item Più tabelle sono seprate da virgole
		\item Se ci sono più tabelle, la semantica prevede che si genera il prodotto cartesiano tra le tabelle e poi si applica il prodotto (clausola) WHERE. Non viene eseguito alcun JOIN naturale.
		\item Non c'è dipendenza dallo schema: gli attributi vengono denotati con: \verb <NomeTabella>.<NomeAttributo>  se ci sono due attributi con nomi uguali in due tabelle distinte.
	\end{itemize}
	


		
\end{document}